<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Spring @Transactional配置]]></title>
      <url>%2F2017%2F10%2F11%2Fspring-transactional%2F</url>
      <content type="text"><![CDATA[在service类前加上@Transactional，声明这个service所有方法需要事务管理。每一个业务方法开始时都会打开一个事务。 Spring默认情况下会对运行期例外(RunTimeException)进行事务回滚。这个例外是unchecked如果遇到checked意外就不回滚。如何改变默认规则： 1 让checked例外也回滚：在整个方法前加上 @Transactional(rollbackFor=Exception.class) 2 让unchecked例外不回滚： @Transactional(notRollbackFor=RunTimeException.class) 3 不需要事务管理的(只查询的)方法：@Transactional(propagation=Propagation.NOT_SUPPORTED) 注意： 如果异常被try｛｝catch｛｝了，事务就不回滚了，如果想让事务回滚必须再往外抛try｛｝catch｛throw Exception｝。 @Transactional设置：propagation：事务传播性设置，Propagation枚举类型。Spring支持的事务传播属性包括7种： PROPAGATION_MANDATORY：方法必须在事务中执行，否则抛出异常。 PROPAGATION_NESTED：使方法运行在嵌套事务中，否则和PROPAGATION_REQUIRED一样。 PROPAGATION_NEVER ：当前方法永远不在事务中运行，否则抛出异常。 PROPAGATION_NOT_SUPPORTED：定义为当前事务不支持的方法，在该方法执行期间正在运行的事务会被暂停 PROPAGATION_REQUIRED：当前的方法必须运行在事务中，如果没有事务就新建一个事务。新事务和方法一起开始，随着方法返回或者抛出异常时终止。 PROPAGATION_REQUIRED_NEW ：当前方法必须新建一个事务，如果当前的事务正在运行则暂停。 PROPAGATION_SUPPORTS ：规定当前方法支持当前事务，但是如果没有事务在运行就使用非事务方法执行。isolation：事务隔离性级别设置，Isolation枚举类型 ISOLATION_DEFAULT ：使用数据库默认的隔离级别 ISOLATION_COMMITTED：允许其他事务已经提交的更新（防止脏读取） ISOLATION_READ_UNCOMMITTED：允许读取其他事务未提交的更新，会导致三个缺陷发生。执行速度最快 ISOLATION_REPEATABLE_READ ：除非事务自身更改了数据，否则事务多次读取的数据相同（防止脏数据，多次重复读取） ISOLATION_SERIALIZABLE：隔离级别最高，可以防止三个缺陷，但是速度最慢，影响性能。 readOnly：读写性事务，只读性事务，布尔型 对数据库的操作中，查询是使用最频繁的操作，每次执行查询时都要从数据库中重新读取数据，有时多次读取的数据都是相同的，这样的数据操作不仅浪费了系统资源，还影响了系统速度。对访问量大的程序来说，节省这部分资源可以大大提 升系统速度。 将事务声明为只读的，那么数据库可以根据事务的特性优化事务的读取操作 timeout：超时时间，单位秒事务可能因为某种原因很长时间没有反应，这期间可能锁定了数据库表，影响性能。设置超时时间，如果超过该时间，事务自动回滚。 rollbackFor：一组异常类的实例，遇到时必须进行回滚rollbackForClassname：一组异常类的名字，遇到时必须进行回滚noRollbackFor：一组异常类的实例，遇到时必须不回滚noRollbackForClassname：一组异常类的名字，遇到时必须不回滚]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Scrapy五大组件介绍]]></title>
      <url>%2F2016%2F02%2F17%2Fscrapy-five-module%2F</url>
      <content type="text"><![CDATA[Scrapy框架主要由五大组件组成，它们分别是调度器(Scheduler)、下载器(Downloader)、爬虫（Spider）和实体管道(Item Pipeline)、Scrapy引擎(Scrapy Engine)。下面我们分别介绍各个组件的作用。 调度器调度器，说白了可以想像成一个URL（抓取网页的网址或者说是链接）的优先队列，由它来决定下一个要抓取的网址是什么，同时去除重复的网址（不做无用功）。用户可以跟据自己的需求定制调度器。 下载器下载器，是所有组件中负担最大的，它用于高速地下载网络上的资源。Scrapy的下载器代码不会太复杂，但效率高，主要的原因是Scrapy下载器是建立在twisted这个高效的异步模型上的(其实整个框架都在建立在这个模型上的)。 爬虫爬虫，是用户最关心的部份。用户定制自己的爬虫，用于从特定的网页中提取自己需要的信息，即所谓的实体(Item)。用户也可以从中提取出链接,让Scrapy继续抓取下一个页面。 实体管道实体管道，用于处理爬虫提取的实体。主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。 Scrapy引擎Scrapy引擎是整个框架的核心。它用来控制调试器、下载器、爬虫。实际上，引擎相当于计算机的CPU,它控制着整个流程。 Scrapy运行流程 首先，引擎从调度器中取出一个链接(URL)用于接下来的抓取 引擎把URL封装成一个请求(Request)传给下载器，下载器把资源下载下来，并封装成应答包(Response) 然后，爬虫解析Response 若是解析出实体（Item）,则交给实体管道进行进一步的处理。 若是解析出的是链接（URL）,则把URL交给Scheduler等待抓取]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Starting MySQL. ERROR]]></title>
      <url>%2F2015%2F09%2F07%2Flinux-mysql-error%2F</url>
      <content type="text"><![CDATA[Starting MySQL. ERROR! The server quit without updating PID file (/var/lib/mysql/iZ94mck3376Z.pid).[root@snsgou mysql]# service mysql restart MySQL server PID file could not be found![失败] Starting MySQL...The server quit without updating PID file (/usr/local/mysql/data/snsgou.pid).[失败] Google了下 ，问题可能的原因有多种，具体什么原因最好的办法是先查看下错误日志： 1、可能是/usr/local/mysql/data/mysql.pid文件没有写的权限解决方法 ：给予权限，执行 “chown -R mysql:mysql /var/data” “chmod -R 755 /usr/local/mysql/data” 然后重新启动mysqld！ 2、可能进程里已经存在mysql进程解决方法：用命令“ps -ef|grep mysqld”查看是否有mysqld进程，如果有使用“kill -9 进程号”杀死，然后重新启动mysqld！ 3、可能是第二次在机器上安装mysql，有残余数据影响了服务的启动。解决方法：去mysql的数据目录/data看看，如果存在mysql-bin.index，就赶快把它删除掉吧，它就是罪魁祸首了。本人就是使用第三条方法解决的 ！ 4、mysql在启动时没有指定配置文件时会使用/etc/my.cnf配置文件，请打开这个文件查看在[mysqld]节下有没有指定数据目录(datadir)。解决方法：请在[mysqld]下设置这一行：datadir = /usr/local/mysql/data 5、skip-federated字段问题解决方法：检查一下/etc/my.cnf文件中有没有没被注释掉的skip-federated字段，如果有就立即注释掉吧。 6、错误日志目录不存在解决方法：使用“chown” “chmod”命令赋予mysql所有者及权限 7、selinux惹的祸，如果是centos系统，默认会开启selinux解决方法：关闭它，打开/etc/selinux/config，把SELINUX=enforcing改为SELINUX=disabled后存盘退出重启机器试试。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate查询语言]]></title>
      <url>%2F2015%2F09%2F04%2Fhibernate-language%2F</url>
      <content type="text"><![CDATA[HQL: Hibernate查询语言Hibernate配备了一种非常强大的查询语言，这种语言看上去很像SQL。但是不要被语法结构 上的相似所迷惑，HQL是非常有意识的被设计为完全面向对象的查询，它可以理解如继承、多态 和关联之类的概念。 Hibernate配备了一种非常强大的查询语言，这种语言看上去很像SQL。但是不要被语法结构 上的相似所迷惑，HQL是非常有意识的被设计为完全面向对象的查询，它可以理解如继承、多态 和关联之类的概念。 1. 大小写敏感性问题除了Java类与属性的名称外，查询语句对大小写并不敏感。 所以 SeLeCT 与 sELEct 以及 SELECT 是相同的，但是 org.hibernate.eg.FOO 并不等价于org.hibernate.eg.Foo 并且 foo.barSet 也不等价于 foo.BARSET。本手册中的HQL关键字将使用小写字母. 很多用户发现使用完全大写的关键字会使查询语句 的可读性更强, 但我们发现，当把查询语句嵌入到Java语句中的时候使用大写关键字比较难看。 2. from子句Hibernate中最简单的查询语句的形式如下： from eg.Cat 该子句简单的返回eg.Cat类的所有实例。 通常我们不需要使用类的全限定名, 因为 auto-import（自动引入） 是缺省的情况。 所以我们几乎只使用如下的简单写法： from Cat 大多数情况下, 你需要指定一个别名, 原因是你可能需要 在查询语句的其它部分引用到Cat from Cat as cat 这个语句把别名cat指定给类Cat 的实例, 这样我们就可以在随后的查询中使用此别名了。 关键字as 是可选的，我们也可以这样写: from Cat cat 子句中可以同时出现多个类, 其查询结果是产生一个笛卡儿积或产生跨表的连接。 from Formula, Parameter from Formula as form, Parameter as param 查询语句中别名的开头部分小写被认为是实践中的好习惯， 这样做与Java变量的命名标准保持了一致 (比如，domesticCat)。 3. 关联(Association)与连接(Join)我们也可以为相关联的实体甚至是对一个集合中的全部元素指定一个别名, 这时要使用关键字join。 from Cat as cat inner join cat.mate as mate left outer join cat.kittens as kitten from Cat as cat left join cat.mate.kittens as kittens from Formula form full join form.parameter param 受支持的连接类型是从ANSI SQL中借鉴来的。 inner join（内连接） left outer join（左外连接） right outer join（右外连接） full join (全连接，并不常用) 语句inner join, left outer join 以及 right outer join 可以简写。 from Cat as cat join cat.mate as mate left join cat.kittens as kitten 还有，一个”fetch”连接允许仅仅使用一个选择语句就将相关联的对象或一组值的集合随着他们的父对象的初始化而被初始化，这种方法在使用到集合的情况下尤其有用，对于关联和集合来说，它有效的代替了映射文件中的外联接 与延迟声明（lazy declarations）. from Cat as cat inner join fetch cat.mate left join fetch cat.kittens 一个fetch连接通常不需要被指定别名, 因为相关联的对象不应当被用在 where 子句 (或其它任何子句)中。同时，相关联的对象并不在查询的结果中直接返回，但可以通过他们的父对象来访问到他们。 注意fetch构造变量在使用了scroll() 或 iterate()函数的查询中是不能使用的。最后注意，使用full join fetch 与 right join fetch是没有意义的。 如果你使用属性级别的延迟获取（lazy fetching）（这是通过重新编写字节码实现的），可以使用 fetch all properties 来强制Hibernate立即取得那些原本需要延迟加载的属性（在第一个查询中）。 from Document fetch all properties order by name from Document doc fetch all properties where lower(doc.name) like &apos;%cats%&apos; 4. select子句select 子句选择将哪些对象与属性返 回到查询结果集中. 考虑如下情况: select mate from Cat as cat inner join cat.mate as mate 该语句将选择mates of other Cats。（其他猫的配偶） 实际上, 你可以更简洁的用以下的查询语句表达相同的含义: select cat.mate from Cat cat 查询语句可以返回值为任何类型的属性，包括返回类型为某种组件(Component)的属性: select cat.name from DomesticCat cat where cat.name like &apos;fri%&apos; select cust.name.firstName from Customer as cust 查询语句可以返回多个对象和（或）属性，存放在 Object[]队列中, select mother, offspr, mate.name from DomesticCat as mother inner join mother.mate as mate left outer join mother.kittens as offspr 或存放在一个List对象中, select new list(mother, offspr, mate.name) from DomesticCat as mother inner join mother.mate as mate left outer join mother.kittens as offspr 也可能直接返回一个实际的类型安全的Java对象, select new Family(mother, mate, offspr) from DomesticCat as mother join mother.mate as mate left join mother.kittens as offspr 假设类Family有一个合适的构造函数.你可以使用关键字as给“被选择了的表达式”指派别名: select max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n from Cat cat 这种做法在与子句select new map一起使用时最有用: select new map( max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n ) from Cat cat 该查询返回了一个Map的对象，内容是别名与被选择的值组成的名-值映射。 5. 聚集函数HQL查询甚至可以返回作用于属性之上的聚集函数的计算结果: select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat) from Cat cat 受支持的聚集函数如下：avg(…), sum(…), min(…), max(…)count(*)count(…), count(distinct …), count(all…) 你可以在选择子句中使用数学操作符、连接以及经过验证的SQL函数： select cat.weight + sum(kitten.weight) from Cat cat join cat.kittens kitten group by cat.id, cat.weight select firstName||&apos; &apos;||initial||&apos; &apos;||upper(lastName) from Person 关键字distinct与all 也可以使用，它们具有与SQL相同的语义. select distinct cat.name from Cat cat select count(distinct cat.name), count(cat) from Cat cat 6. 多态查询一个如下的查询语句: from Cat as cat 不仅返回Cat类的实例, 也同时返回子类 DomesticCat的实例. Hibernate 可以在from子句中指定任何 Java 类或接口. 查询会返回继承了该类的所有持久化子类 的实例或返回声明了该接口的所有持久化类的实例。下面的查询语句返回所有的被持久化的对象： from java.lang.Object o 接口Named 可能被各种各样的持久化类声明： from Named n, Named m where n.name = m.name 注意，最后的两个查询将需要超过一个的SQL SELECT.这表明order by子句 没有对整个结果集进行正确的排序. (这也说明你不能对这样的查询使用Query.scroll()方法.) 7. where子句where子句允许你将返回的实例列表的范围缩小. 如果没有指定别名，你可以使用属性名来直接引用属性: from Cat where name=&apos;Fritz&apos; 如果指派了别名，需要使用完整的属性名: from Cat as cat where cat.name=&apos;Fritz&apos; 返回名为（属性name等于）’Fritz’的Cat类的实例。 select foo from Foo foo, Bar bar where foo.startDate = bar.date 将返回所有满足下面条件的Foo类的实例： 存在如下的bar的一个实例，其date属性等于 Foo的startDate属性。 复合路径表达式使得where子句非常的强大，考虑如下情况： from Cat cat where cat.mate.name is not null 该查询将被翻译成为一个含有表连接（内连接）的SQL查询。如果你打算写像这样的查询语句 from Foo foo where foo.bar.baz.customer.address.city is not null 在SQL中，你为达此目的将需要进行一个四表连接的查询。=运算符不仅可以被用来比较属性的值，也可以用来比较实例： from Cat cat, Cat rival where cat.mate = rival.mate select cat, mate from Cat cat, Cat mate where cat.mate = mate 特殊属性（小写）id可以用来表示一个对象的唯一的标识符。（你也可以使用该对象的属性名。） from Cat as cat where cat.id = 123 from Cat as cat where cat.mate.id = 69 第二个查询是有效的。此时不需要进行表连接！同样也可以使用复合标识符。比如Person类有一个复合标识符，它由country属性 与medicareNumber属性组成。 from bank.Person person where person.id.country = &apos;AU&apos; and person.id.medicareNumber = 123456 from bank.Account account where account.owner.id.country = &apos;AU&apos; and account.owner.id.medicareNumber = 123456 第二个查询也不需要进行表连接。同样的，特殊属性class在进行多态持久化的情况下被用来存取一个实例的鉴别值（discriminator value）。 一个嵌入到where子句中的Java类的名字将被转换为该类的鉴别值。 from Cat cat where cat.class = DomesticCat 你也可以声明一个属性的类型是组件或者复合用户类型（以及由组件构成的组件等等）。永远不要尝试使用以组件类型来结尾的路径表达式（path-expression） （与此相反，你应当使用组件的一个属性来结尾）。 举例来说，如果store.owner含有一个包含了组件的实体addressstore.owner.address.city // 正确store.owner.address // 错误!一个“任意”类型有两个特殊的属性id和class, 来允许我们按照下面的方式表达一个连接（AuditLog.item 是一个属性，该属性被映射为）。 from AuditLog log, Payment payment where log.item.class = &apos;Payment&apos; and log.item.id = payment.id 注意，在上面的查询与句中，log.item.class 和 payment.class 将涉及到完全不同的数据库中的列。 8. 表达式在where子句中允许使用的表达式包括 大多数你可以在SQL使用的表达式种类: 数学运算符+, -, *, /二进制比较运算符=, &gt;=, &lt;=, &lt;&gt;, !=, like逻辑运算符and, or, notin, not in, between, is null, is not null, is empty, is not empty, member of and not member of“简单的” case, case … when … then … else … end,和 “搜索” case, case when … then … else … end字符串连接符…||… or concat(…,…)current_date(), current_time(), current_timestamp()second(…), minute(…), hour(…), day(…), month(…), year(…),EJB-QL 3.0定义的任何函数或操作：substring(), trim(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length()coalesce() 和 nullif()cast(… as …), 其第二个参数是某Hibernate类型的名字，以及extract(… from …)，只要ANSI cast() 和 extract() 被底层数据库支持任何数据库支持的SQL标量函数，比如sign(), trunc(), rtrim(), sin() JDBC参数传入 ?命名参数:name, :start_date, :x1SQL 直接常量 ‘foo’, 69, ‘1970-01-01 10:00:01.0’Java public static final 类型的常量 eg.Color.TABBY 关键字in与between可按如下方法使用: from DomesticCat cat where cat.name between &apos;A&apos; and &apos;B&apos; from DomesticCat cat where cat.name in ( &apos;Foo&apos;, &apos;Bar&apos;, &apos;Baz&apos; ) 而且否定的格式也可以如下书写： from DomesticCat cat where cat.name not between &apos;A&apos; and &apos;B&apos; from DomesticCat cat where cat.name not in ( &apos;Foo&apos;, &apos;Bar&apos;, &apos;Baz&apos; ) 同样, 子句is null与is not null可以被用来测试空值(null).在Hibernate配置文件中声明HQL“查询替代（query substitutions）”之后， 布尔表达式（Booleans）可以在其他表达式中轻松的使用: &lt;property name=&quot;hibernate.query.substitutions&quot;&gt;true 1, false 0&lt;/property&gt; 系统将该HQL转换为SQL语句时，该设置表明将用字符 1 和 0 来 取代关键字true 和 false: from Cat cat where cat.alive = true 你可以用特殊属性size, 或是特殊函数size()测试一个集合的大小。 from Cat cat where cat.kittens.size &gt; 0 from Cat cat where size(cat.kittens) &gt; 0 对于索引了（有序）的集合，你可以使用minindex 与 maxindex函数来引用到最小与最大的索引序数。 同理，你可以使用minelement 与 maxelement函数来 引用到一个基本数据类型的集合中最小与最大的元素。 from Calendar cal where maxelement(cal.holidays) &gt; current date from Order order where maxindex(order.items) &gt; 100 from Order order where minelement(order.items) &gt; 10000 在传递一个集合的索引集或者是元素集(elements与indices 函数) 或者传递一个子查询的结果的时候，可以使用SQL函数any, some, all, exists, in select mother from Cat as mother, Cat as kit where kit in elements(foo.kittens) select p from NameList list, Person p where p.name = some elements(list.names) from Cat cat where exists elements(cat.kittens) from Player p where 3 &gt; all elements(p.scores) from Show show where &apos;fizard&apos; in indices(show.acts) 注意，在Hibernate3种，这些结构变量- size, elements, indices, minindex, maxindex, minelement, maxelement - 只能在where子句中使用。一个被索引过的（有序的）集合的元素(arrays, lists, maps)可以在其他索引中被引用（只能在where子句中）： from Order order where order.items[0].id = 1234 select person from Person person, Calendar calendar where calendar.holidays[&apos;national day&apos;] = person.birthDay and person.nationality.calendar = calendar select item from Item item, Order order where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11 select item from Item item, Order order where order.items[ maxindex(order.items) ] = item and order.id = 11 在[]中的表达式甚至可以是一个算数表达式。 select item from Item item, Order order where order.items[ size(order.items) - 1 ] = item 对于一个一对多的关联（one-to-many association）或是值的集合中的元素， HQL也提供内建的index()函数， select item, index(item) from Order order join order.items item where index(item) &lt; 5 如果底层数据库支持标量的SQL函数，它们也可以被使用 from DomesticCat cat where upper(cat.name) like &apos;FRI%&apos; 如果你还不能对所有的这些深信不疑，想想下面的查询。如果使用SQL，语句长度会增长多少，可读性会下降多少： select cust from Product prod, Store store inner join store.customers cust where prod.name = &apos;widget&apos; and store.location.name in ( &apos;Melbourne&apos;, &apos;Sydney&apos; ) and prod = all elements(cust.currentOrder.lineItems) 提示: 会像如下的语句 SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order FROM customers cust, stores store, locations loc, store_customers sc, product prod WHERE prod.name = &apos;widget&apos; AND store.loc_id = loc.id AND loc.name IN ( &apos;Melbourne&apos;, &apos;Sydney&apos; ) AND sc.store_id = store.id AND sc.cust_id = cust.id AND prod.id = ALL( SELECT item.prod_id FROM line_items item, orders o WHERE item.order_id = o.id AND cust.current_order = o.id ) 9. order by子句查询返回的列表(list)可以按照一个返回的类或组件（components)中的任何属性（property）进行排序： from DomesticCat cat order by cat.name asc, cat.weight desc, cat.birthdate 可选的asc或desc关键字指明了按照升序或降序进行排序. 10. group by子句一个返回聚集值(aggregate values)的查询可以按照一个返回的类或组件（components)中的任何属性（property）进行分组： select cat.color, sum(cat.weight), count(cat) from Cat cat group by cat.color select foo.id, avg(name), max(name) from Foo foo join foo.names name group by foo.id having子句在这里也允许使用. select cat.color, sum(cat.weight), count(cat) from Cat cat group by cat.color having cat.color in (eg.Color.TABBY, eg.Color.BLACK) 如果底层的数据库支持的话(例如不能在MySQL中使用)，SQL的一般函数与聚集函数也可以出现 在having与order by 子句中。 select cat from Cat cat join cat.kittens kitten group by cat having avg(kitten.weight) &gt; 100 order by count(kitten) asc, sum(kitten.weight) desc 注意group by子句与 order by子句中都不能包含算术表达式（arithmetic expressions）. 11. 子查询对于支持子查询的数据库，Hibernate支持在查询中使用子查询。一个子查询必须被圆括号包围起来（经常是SQL聚集函数的圆括号）。 甚至相互关联的子查询（引用到外部查询中的别名的子查询）也是允许的。 from Cat as fatcat where fatcat.weight &gt; ( select avg(cat.weight) from DomesticCat cat ) from DomesticCat as cat where cat.name = some ( select name.nickName from Name as name ) from Cat as cat where not exists ( from Cat as mate where mate.mate = cat ) from DomesticCat as cat where cat.name not in ( select name.nickName from Name as name ) 在select列表中包含一个表达式以上的子查询，你可以使用一个元组构造符（tuple constructors）： from Cat as cat where not ( cat.name, cat.color ) in ( select cat.name, cat.color from DomesticCat cat ) 注意在某些数据库中（不包括Oracle与HSQL），你也可以在其他语境中使用元组构造符， 比如查询用户类型的组件与组合： from Person where name = (&apos;Gavin&apos;, &apos;A&apos;, &apos;King&apos;) 该查询等价于更复杂的： from Person where name.first = &apos;Gavin&apos; and name.initial = &apos;A&apos; and name.last = &apos;King&apos;) 有两个很好的理由使你不应当作这样的事情：首先，它不完全适用于各个数据库平台；其次，查询现在依赖于映射文件中属性的顺序。 12. HQL示例Hibernate查询可以非常的强大与复杂。实际上，Hibernate的一个主要卖点就是查询语句的威力。这里有一些例子，它们与我在最近的 一个项目中使用的查询非常相似。注意你能用到的大多数查询比这些要简单的多！下面的查询对于某个特定的客户的所有未支付的账单，在给定给最小总价值的情况下，返回订单的id，条目的数量和总价值， 返回值按照总价值的结果进行排序。为了决定价格，查询使用了当前目录。作为转换结果的SQL查询，使用了ORDER, ORDER_LINE, PRODUCT, CATALOG 和PRICE 库表。 select order.id, sum(price.amount), count(item) from Order as order join order.lineItems as item join item.product as product, Catalog as catalog join catalog.prices as price where order.paid = false and order.customer = :customer and price.product = product and catalog.effectiveDate &lt; sysdate and catalog.effectiveDate &gt;= all ( select cat.effectiveDate from Catalog as cat where cat.effectiveDate &lt; sysdate ) group by order having sum(price.amount) &gt; :minAmount order by sum(price.amount) desc 这简直是一个怪物！实际上，在现实生活中，我并不热衷于子查询，所以我的查询语句看起来更像这个： select order.id, sum(price.amount), count(item) from Order as order join order.lineItems as item join item.product as product, Catalog as catalog join catalog.prices as price where order.paid = false and order.customer = :customer and price.product = product and catalog = :currentCatalog group by order having sum(price.amount) &gt; :minAmount order by sum(price.amount) desc 下面一个查询计算每一种状态下的支付的数目，除去所有处于AWAITING_APPROVAL状态的支付，因为在该状态下 当前的用户作出了状态的最新改变。该查询被转换成含有两个内连接以及一个相关联的子选择的SQL查询，该查询使用了表 PAYMENT, PAYMENT_STATUS 以及 PAYMENT_STATUS_CHANGE。 select count(payment), status.name from Payment as payment join payment.currentStatus as status join payment.statusChanges as statusChange where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL or ( statusChange.timeStamp = ( select max(change.timeStamp) from PaymentStatusChange change where change.payment = payment ) and statusChange.user &lt;&gt; :currentUser ) group by status.name, status.sortOrder order by status.sortOrder 如果我把statusChanges实例集映射为一个列表（list）而不是一个集合（set）, 书写查询语句将更加简单. select count(payment), status.name from Payment as payment join payment.currentStatus as status where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL or payment.statusChanges[ maxIndex(payment.statusChanges) ].user &lt;&gt; :currentUser group by status.name, status.sortOrder order by status.sortOrder 下面一个查询使用了MS SQL Server的 isNull()函数用以返回当前用户所属组织的组织帐号及组织未支付的账。 它被转换成一个对表ACCOUNT,PAYMENT, PAYMENT_STATUS, ACCOUNT_TYPE, ORGANIZATION 以及 ORG_USER进行的三个内连接， 一个外连接和一个子选择的SQL查询。 select account, payment from Account as account left outer join account.payments as payment where :currentUser in elements(account.holder.users) and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID) order by account.type.sortOrder, account.accountNumber, payment.dueDate 对于一些数据库，我们需要弃用（相关的）子选择。 select account, payment from Account as account join account.holder.users as user left outer join account.payments as payment where :currentUser = user and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID) order by account.type.sortOrder, account.accountNumber, payment.dueDate 13. 批量的UPDATE &amp; DELETE语句HQL现在支持UPDATE与DELETE语句. 查阅 第 14.3 节 “大批量更新/删除（Bulk update/delete）” 以获得更多信息。 14. 小技巧 &amp; 小窍门你可以统计查询结果的数目而不必实际的返回他们：( (Integer) session.iterate(“select count(*) from ….”).next() ).intValue()若想根据一个集合的大小来进行排序，可以使用如下的语句： select usr.id, usr.name from User as usr left join usr.messages as msg group by usr.id, usr.name order by count(msg) 如果你的数据库支持子选择，你可以在你的查询的where子句中为选择的大小（selection size）指定一个条件: from User usr where size(usr.messages) &gt;= 1 如果你的数据库不支持子选择语句，使用下面的查询： select usr.id, usr.name from User usr.name join usr.messages msg group by usr.id, usr.name having count(msg) &gt;= 1 因为内连接（inner join）的原因，这个解决方案不能返回含有零个信息的User 类的实例, 所以这种情况下使用下面的格式将是有帮助的: select usr.id, usr.name from User as usr left join usr.messages as msg group by usr.id, usr.name having count(msg) = 0 JavaBean的属性可以被绑定到一个命名查询（named query）的参数上： Query q = s.createQuery(&quot;from foo Foo as foo where foo.name=:name and foo.size=:size&quot;); q.setProperties(fooBean); // fooBean包含方法getName()与getSize() List foos = q.list(); 通过将接口Query与一个过滤器（filter）一起使用，集合（Collections）是可以分页的： Query q = s.createFilter( collection, &quot;&quot; ); // 一个简单的过滤器 q.setMaxResults(PAGE_SIZE); q.setFirstResult(PAGE_SIZE * pageNumber); List page = q.list(); 通过使用查询过滤器（query filter）可以将集合（Collection）的原素分组或排序: Collection orderedCollection = s.filter( collection, &quot;order by this.amount&quot; ); Collection counts = s.filter( collection, &quot;select this.type, count(this) group by this.type&quot; ); 不用通过初始化，你就可以知道一个集合（Collection）的大小： ( (Integer) session.iterate(&quot;select count(*) from ....&quot;).next() ).intValue();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[springmvc4-date-json]]></title>
      <url>%2F2015%2F08%2F29%2Fspringmvc4-date-json%2F</url>
      <content type="text"><![CDATA[1、方法一：全局处理&lt;mvc:annotation-driven&gt; &lt;!-- 处理responseBody 里面日期类型 --&gt; &lt;mvc:message-converters&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;&gt; &lt;property name=&quot;dateFormat&quot;&gt; &lt;bean class=&quot;java.text.SimpleDateFormat&quot;&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;yyyy-MM-dd HH:mm:ss&quot; /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 方法二：局部注解处理123456789101112131415161718192021222324252627282930313233343536import java.io.IOException; import java.text.SimpleDateFormat; import java.util.Date; import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.JsonSerializer; import com.fasterxml.jackson.databind.SerializerProvider; /** * ClassName:DateJsonSerializer &lt;br/&gt; * Function: 日期类型格式化，格式化为：yyyy-MM-dd HH:mm:ss 格式. 用法如下：&lt;br/&gt; * Reason: @JsonSerialize(using=DateJsonSerializer.class) * @Column(name=&quot;BIRTHDAY&quot;) * public Date getBirthday() &#123; * return birthday; * &#125; * . &lt;br/&gt; * Date: 2014年7月10日 下午1:26:08 &lt;br/&gt; * @author zhangzhaoyu * @version 1.0 * @since JDK 1.7 * @see */ public class DateJsonSerializer extends JsonSerializer&lt;Date&gt; &#123; @Override public void serialize(Date value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException &#123; SimpleDateFormat formatter = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); String formattedDate = formatter.format(value); jgen.writeString(formattedDate); &#125; &#125; 方法三：jackson 注解处理@JsonIgnoreProperties此注解是类注解，作用是json序列化时将javabean中的一些属性忽略掉，序列化和反序列化都受影响。 @JsonIgnore此注解用于属性或者方法上（最好是属性上），作用和上面的@JsonIgnoreProperties一样。 @JsonFormat此注解用于属性或者方法上（最好是属性上），可以方便的把Date类型直接转化为我们想要的模式，比如@JsonFormat(pattern = “yyyy-MM-dd HH-mm-ss”) @JsonSerialize 1234567891011121314151617181920212223242526272829 // 反序列化一个固定格式的Date @JsonDeserialize(using = CustomDateDeserialize.class) public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; // 序列化指定格式的double格式 @JsonSerialize(using = CustomDoubleSerialize.class) public double getSalary() &#123; return salary; &#125; public class CustomDateDeserialize extends JsonDeserializer&lt;Date&gt; &#123; private SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); @Override public Date deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException &#123; Date date = null; try &#123; date = sdf.parse(jp.getText()); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSON 中JsonConfig的使用]]></title>
      <url>%2F2015%2F08%2F29%2FJson-jsonconfig%2F</url>
      <content type="text"><![CDATA[我们通常对一个Json串和java对象进行互转时，经常会有选择性的过滤掉一些属性值，而json-lib包中的JsonConfig为我们提供了这种 功能，具体实现方法有以下几种。(1)建立JsonConfig实例，并配置属性排除列表,(2)用属性过滤器,(3)写一个自定义的 JsonBeanProcessor. 1. 实现JSONString接口的方法1234567891011public class Person implements JSONString &#123; private String name; private String lastname; private Address address; // getters &amp; setters public String toJSONString() &#123;return &quot;&#123;name:&apos;&quot;+name+&quot;&apos;,lastname:&apos;&quot;+lastname+&quot;&apos;&#125;&quot;;&#125;&#125; 2.第二种方法通过jsonconfig实例，对包含和需要排除的属性进行方便的添加或删除1234567891011public class Person &#123; private String name; private String lastname; private Address address; // getters &amp; setters // &#125; JsonConfig jsonConfig = new JsonConfig(); jsonConfig.setExclusions( new String[]&#123;&quot;address&quot;&#125;); Person bean = new Person(&quot;jack&quot;,&quot;li&quot;); JSON json = JSONSerializer.toJSON(bean, jsonConfig); 3. 使用propertyFilter可以允许同时对需要排除的属性和类进行控制，这种控制还可以是双向的，也可以应用到json字符串到java对象123456789101112131415161718public class Person &#123; private String name; private String lastname; private Address address; // getters &amp; setters &#125; JsonConfig jsonConfig = new JsonConfig(); jsonConfig.setJsonPropertyFilter( new PropertyFilter()&#123; public boolean apply(Object source/* 属性的拥有者 */ , String name /*属性名字*/ , Object value/* 属性值 */ )&#123; // return true to skip name return source instanceof Person &amp;&amp; name.equals(&quot;address&quot;); &#125; &#125;); Person bean = new Person(&quot;jack&quot;,&quot;li&quot;); JSON json = JSONSerializer.toJSON( bean, jsonConfig ) 4. 最后来看JsonBeanProcessor,这种方式和实现JsonString很类似，返回一个代表原来的domain类的合法JSONObject12345678910111213141516171819202122public class Person &#123; private String name; private String lastname; private Address address; // getters &amp; setters &#125; JsonConfig jsonConfig = new JsonConfig(); jsonConfig.registerJsonBeanProcessor( Person.class, new JsonBeanProcessor()&#123; public JSONObject processBean( Object bean, JsonConfig jsonConfig )&#123; if(!(bean instanceof Person))&#123; return new JSONObject(true); &#125; Person person = (Person) bean; return new JSONObject() .element( &quot;name&quot;, person.getName()) .element( &quot;lastname&quot;, person.getLastname()); &#125; &#125;); Person bean = new Person(&quot;jack&quot;,&quot;li&quot;); JSON json = JSONSerializer.toJSON( bean, jsonConfig );]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Centos6.4 用rpm方式安装MySql5.6]]></title>
      <url>%2F2015%2F07%2F26%2Fcentos-install-mysql%2F</url>
      <content type="text"><![CDATA[Centos6.4 用rpm方式安装MySql5.61. 查看系统是否安装了MySQL使用命令： #rpm -qa | grep mysql 2. 卸载已安装的MySQL卸载mysql命令如下： #rpm -e --nodeps mysql-libs-5.1.61-4.el6.x86_64 要将 /var/lib/mysql文件夹下的所有文件都删除干净 3. 安装新的MySQL命令如下： #rpm -ivh MySQL-server-5.5.30-1.el6.x86_64.rpm #rpm -ivh MySQL-client-5.5.30-1.el6.x86_64.rpm #rpm -ivh MySQL-devel-5.5.30-1.el6.x86_64.rpm 4. 启动MySQL服务方法一：重新启动系统 方法二：#service mysql start 查看MySQL运行状态的方法： 使用命令：# /etc/rc.d/init.d/mysql status 结果： 显示 “SUCCESS” 则已经运行 显示 “FAILED” 则没有运行 5. MySQL服务一些其他命令a、察看mysql是否在自动启动列表： # /sbin/chkconfig –list b、添加mysql到系统自启动服务组： # /sbin/chkconfig – add mysql c、把mysql从启动服务组中删除： # /sbin/chkconfig – del mysql d、停止mysql服务： # service mysql stop e、脚本启动mysql服务： # /etc/rc.d/init.d/mysqld start f、脚本停止mysql服务： # /etc/rc.d/init.d/mysqld stop 6、安装完成之后为MySQL设置root密码。命令如下： # mysql -u root -p 会提示输入密码，初始root密码保存在’/root/.mysql_secret’文件中接着输入 mysql&gt;SET PASSWORD = PASSWORD(&apos;123456&apos;); 7、mysql安装目录说明/var/lib/mysql 数据库文件 /usr/share/mysql 命令及配置文件 /usr/bin (mysqladmin、mysqldump等命令) 8、linux 下安装的mysql表名是区分大小写的，如果要不区分大小写，可以采用以下方式 1、拷贝 /usr/share/mysql/my-huge.cnf到/etc/my.cnf（如果已有该文件可以直接修改） 命令如下： # cp /usr/share/mysql/my-huge.cnf /etc/my.cnf 2、修改my.cnf 文件 在 [mysqld]下增加 lower_case_table_names=1 #表名全部为小写，避免出现大小写敏感 3、重启mysql # service mysql restart 9(可选)、为连接MySQL的主机分配权限： 命令如下： &gt;mysql GRANT SELECT,INSERT,UPDATE,DELETE ON *.* TO root@xxx.xxx.x.xxidentified by &apos;123456&apos;; //xxx.xxx.x.xx是你的IP 10、开机启动MySQL用root用户登录终端 查看是否已经有MySQL的服务 # chkconfig --list 如果没有MySQL(如果有请忽略这个步骤) # chkconfig --add mysql 设置开机启动mysql服务 # chkconfig mysql on 11(可选)、更改MySQL默认字符集 (默认字符集和操作系统字符集一样，所以不需要设置)查看mysql字符集： mysql&gt; show variables like &apos;character_set_%&apos;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[maven 不能设置为web3.0人解决方法]]></title>
      <url>%2F2015%2F03%2F12%2Fmaven-eclipse%2F</url>
      <content type="text"><![CDATA[错误： Description Resource Path Location Type Cannot change version of project facet Dynamic Web Module to 3.0. 以下是在GG搜索到的。http://stackoverflow.com/questions/75786/eclipse-how-can-i-change-a-project-facet-from-tomcat-6-to-tomcat-5-5 首先在硬盘下找到\项目名\setting\文件夹下的org.eclipse.wst.common.project.facet.core.xml xml文件。 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;faceted-project&gt; &lt;fixed facet=&quot;wst.jsdt.web&quot;/&gt; &lt;installed facet=&quot;jst.web&quot; version=&quot;2.3&quot;/&gt; &lt;installed facet=&quot;wst.jsdt.web&quot; version=&quot;1.0&quot;/&gt; &lt;installed facet=&quot;java&quot; version=&quot;1.7&quot;/&gt;&lt;/faceted-project&gt; 将jst.web，的version改成3.0.然后在eclipse里右键该工程–maven–updateProject即可。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2015%2F01%2F02%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
